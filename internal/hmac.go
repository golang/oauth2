package internal

// hmac stuff
import (
    "crypto/hmac"
    "crypto/sha256"
    "crypto/sha1"
    "encoding/base64"
    "fmt"
)

// request augmentation stuff
import (
    "time"
    "net/http"
    "strings"
    "strconv"
    "errors"
)

type HMACComputer func(normalizedRequest, secret string) string

func ComputeHMAC256(normalizedRequest, secret string) string {
    key := []byte(secret)
    h := hmac.New(sha256.New, key)
    h.Write([]byte(normalizedRequest))
    return base64.StdEncoding.EncodeToString(h.Sum(nil))
}

func ComputeHMAC1(normalizedRequest, secret string) string {
    key := []byte(secret)
    h := hmac.New(sha1.New, key)
    h.Write([]byte(normalizedRequest))
    return base64.StdEncoding.EncodeToString(h.Sum(nil))
}

// Everything below is based on the following IETF draft for OAuth v2
// http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-3.1

// IETF OAuth V2 draft:
// REQUIRED.  A unique string generated by the client.  The value
// MUST be unique across all requests with the same timestamp and
// MAC key identifier combination.
const nonceSalt = "thanks-for-all-the-fish"

func getNonce(timestamp int64) string {
    str := fmt.Sprintf("a7xf6g%s%s9", nonceSalt, timestamp)
    hash := sha1.New()
    hash.Write([]byte(str))
    return fmt.Sprintf("%x", hash.Sum(nil))
}

// IETF OAuth V2 draft:
// The HTTP request method in upper case.  For example: "HEAD",
// "GET", "POST", etc.
//
// NOTE: When Request.Method is empty, that means it is a GET
func getMethod(r *http.Request) string {
    method := strings.ToUpper(r.Method)
    if len(method) == 0 {
        method = "GET"
    }
    return method
}

// IETF OAuth V2 draft:
// The port as included in the HTTP request using the "Host" request
// header field.  If the header field does not include a port, the
// default value for the scheme MUST be used (e.g. 80 for HTTP and
// 443 for HTTPS).
//
// NOTE: Returning string since that is how it will be used later anyways
func getPort(r *http.Request) string {
    hostSlices := strings.Split(r.URL.Host, ":")

    if len(hostSlices) == 2 { // host contains port
        return hostSlices[1]
    } else if r.URL.Scheme == "http" {
        return "80"
    } else if r.URL.Scheme == "https" {
        return "443"
    } else {
        // TODO: fuck stuff up (or just port 80)
        return "-1"
    }
}

// IETF OAuth V2 draft:
// The hostname included in the HTTP request using the "Host"
// request header field in lower case.
func getHostname(r *http.Request) string {
    hostSlices := strings.Split(r.URL.Host, ":")

    return strings.ToLower(hostSlices[0])
}

// IETF OAuth V2 draft:
// The HTTP request-URI as defined by [RFC2616] section 5.1.2.
func getRequestURI(r *http.Request) string {
    return r.URL.RequestURI()
}

// HMAC supports sha1 and sha256
func getEncryptor(algorithm string) (HMACComputer, error) {
    algorithm = strings.ToLower(algorithm)

    if algorithm == "hmac-sha-1" {
        return ComputeHMAC1, nil
    } else if algorithm == "hmac-sha-256" {
        return ComputeHMAC256, nil
    } else {
        return nil, errors.New("invalid hmac algorithm supplied")
    }
}

func getAuthHeader(accessToken, ts, nonce, mac string) string {
    formatStr := "MAC id=\"%s\", ts=\"%s\", nonce=\"%s\", mac=\"%s\""

    return fmt.Sprintf(formatStr, accessToken, ts, nonce, mac)
}

// this is such a piece of crap
func AddHMACOauthToHeader(r *http.Request, accessToken, macKey, macAlgorithm string) {
    timestampNano := time.Now().UnixNano()

    // Variables for the Normalized Request String
    ts := strconv.Itoa(int(timestampNano / 1000000000)) // make seconds from ns
    nonce := getNonce(timestampNano)
    method := getMethod(r)
    requestURI := getRequestURI(r)
    hostname := getHostname(r)
    port := getPort(r)

    lines := []string{ts, nonce, method, requestURI, hostname, port}
    normalizedRequest := strings.Join(lines, "\n") + "\n\n"

    // macKey := t.Extra("MacKey")
    // macAlgorithm := t.Extra("MacAlgorithm")
    encryptor, _ := getEncryptor(macAlgorithm)
    requestMAC := encryptor(normalizedRequest, macKey)

    r.Header.Set("Authorization",
                 getAuthHeader(accessToken, ts, nonce, requestMAC))
}
